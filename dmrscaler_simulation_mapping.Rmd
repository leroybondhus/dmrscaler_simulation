---
title: "dmrscaler_simulation_mapping"
author: "Leroy_Bondhus"
date: "July 28, 2020"
output: html_document
---

```{r}
library("devtools")
library(roxygen2)


library(minfi)
library(doParallel)
library(rlang)
library(MESS)

library("valr")
library(IRanges)
library(GenomicRanges)
registerDoParallel()


library("sva")
library("minfiData")
library("minfi")
library("IlluminaHumanMethylationEPICmanifest") ###### NOTE hg19 is used IlluminaHumanMethylation450kanno.ilmn.hg19
                                                ###### NOTE New mapping is used:
                                                ######                   IlluminaHumanMethylationEPICanno.ilm10b4.hg19
library(tidyverse)
library(ggplot2)
library(gridExtra)

library(DMRcate)
document("/home/lbondhus/Desktop/PROJECTS/dmrscaler")
install("/home/lbondhus/Desktop/PROJECTS/dmrscaler")

results_dir <-paste("/home/lbondhus/Desktop/PROJECTS/dmrscaler_simulation/results/")
```



```{r}
simul_sc_tbl <- data.frame("min_cgs"=c(3,6,9,12), "size"=c(1e3,1e4,1e5,1e6), "count"=c(50,50,50,50) )
```


```{r }
locs<-read.csv("/home/lbondhus/Desktop/PROJECTS/dmrscaler_simulation/intermediate_data/Control_CG_locs_full.csv", row.names = 1)
locs$names <- as.character(locs$names)
B<-read.csv("/home/lbondhus/Desktop/PROJECTS/dmrscaler_simulation/intermediate_data/Control_Beta_Matrix_full.csv", row.names = 1)
pdat<-read.csv("/home/lbondhus/Desktop/PROJECTS/dmrscaler_simulation/intermediate_data/Control_Pheno_Data_full.csv", row.names = 1)


## DMRcate uses M values

```


```{r}

## delta_beta = artificial inflation of beta values between groups
## num_samples = number of samples for each group
## noise = proportion of cgs in DMR that are not to have an altered beta value
## dmr_buffer = number of non-dmr cgs to enforce between each artificial dmr

pars <- data.frame("delta_beta" = 0.2, "num_samples" = 10, "noise" = 0.5, "dmr_buffer" = 10) 
```


```{r select dmrs ranges}
locs$in_dmr <- rep(0, nrow(locs))
locs$dmr_size <- rep(0, nrow(locs))
#locs$dmr_left_bound <- rep(0, nrow(locs))
#locs$dmr_right_bound <- rep(0, nrow(locs))
locs$dmr_name <- rep("", nrow(locs))

for(i in 1:nrow(simul_sc_tbl)){
    size <- simul_sc_tbl[i,]$size
    min_cgs <- simul_sc_tbl[i,]$min_cgs
    count <- simul_sc_tbl[i,]$count
   
    while(count > 0){
        size_sampled <-sample(floor(size/10)+1:size,1) 
        x <- sample(1:nrow(locs),1)
        x_loc <-locs[x,]
        x_which <- which(locs$chr == x_loc$chr & locs$pos >= x_loc$pos & locs$pos <= x_loc$pos+size_sampled )
        x_which_left <- min(x_which)-10
        x_which_right <- max(x_which)+10
        if(x_which_left <  min(which(locs$chr == x_loc$chr)) ){next;} ## test if valid left bound
        if(x_which_right > max(which(locs$chr == x_loc$chr)) ){next;} ## test if valid right bound
        if(length(x_which) >= min_cgs  ## at least min_cgs 
           & sum(locs$in_dmr[x_which_left:x_which_right])==0   ## not overlapping a dmr that already exists
            & (locs$pos[max(x_which)]-locs$pos[min(x_which)] >= size/10)  ##  size is between size/2 and size
           ){ ## min number cgs achieved and none in dmr already...
            
            x_which <- unique(c(min(x_which), sample(x_which, ceiling((1-pars$noise) * length(x_which) )  ) ,max(x_which))) ## sample left and right most cg and introduce noise 
            locs$in_dmr[x_which] <- 1
            locs$dmr_size[x_which] <- locs$pos[max(x_which)]-locs$pos[min(x_which)]
            locs$dmr_name[x_which] <- paste("dmr", size, count, sep = "_")
            # locs$dmr_left_bound[min(x_which)] <- 1
            # locs$dmr_right_bound[max(x_which)] <- 1
            count<-count-1
            
        }
    }
}

#hist(log10(locs$dmr_size[which(locs$in_dmr==1)]), breaks=200)
#locs$pos[35041] - locs$pos[34998]

locs$chr <- as.character(locs$chr)  ## remove factor 


```


```{r select two groups to simulate dmr in}
g12 <- sample(rownames(pdat), 2*pars$num_samples, replace = FALSE)
g1 <- g12[1:pars$num_samples]
g2 <- g12[(pars$num_samples+1):length(g12)]
```

```{r simulate dmrs in beta matrix}
B_mod <- as.matrix(B[,g12])

dmr_names <- unique(locs$dmr_name)[which(unique(locs$dmr_name)!="")]
for(i in 1:length(dmr_names)){
  dmr_i <- dmr_names[i]
  locs_i <- locs$names[which(locs$dmr_name==dmr_i)]
  mean_g1_i <- mean(as.matrix(B_mod[locs_i,g1]))
  mean_g2_i <- mean(as.matrix(B_mod[locs_i,g2]))
  if(mean_g1_i > mean_g2_i){
     B_mod[locs_i, g1] <- B_mod[locs_i, g1]+pars$delta_beta 
  }else{ 
      B_mod[locs_i, g2] <- B_mod[locs_i, g2]+pars$delta_beta 
  }
}

## renormalize rows where B > 1
for(i in 1:nrow(B_mod)){
  if(any(B_mod[i,]>1)){
    B_mod[i,] <- B_mod[i,] / max(B_mod[i,] )
  }
}

B_test <- B[,g12]
hist(as.matrix(B_test)-as.matrix(B_mod)) 

length(is.element(rownames(B_mod)[which(rowMeans(as.matrix(B_test))-rowMeans(as.matrix(B_mod)) < -0.1)], locs$names[which(locs$in_dmr==1)]))

```


```{r}
      
      ############################     run everything         #########################
      num_perm <- 10
      #clt_reps <- 5e5
      clt_reps <- 5e4
      
      rim <- dmrscaler::generate_rand_index_matrix(num_controls = length(g1),
                                                   num_cases = length(g2),
                                                   num_permutations = num_perm)
      mrp <- dmrscaler::run_MWW_rand_permutation(index_matrix = rim, 
                                                 Beta = B_mod,
                                                 num_permutations = num_perm)
      mrp <- -log10(mrp)
      mwr <- dmrscaler::run_MWW(control_indices = which(colnames(B_mod)==g1) ,
                                case_indices = which(colnames(B_mod)==g2),
                                Beta = B_mod)
      mwr <- -log10(mwr)
      fdt <- dmrscaler::write_FDR_table(real_table = mwr,
                                        rand_table = mrp)
      
      fdrscaler <- dmrscaler::get_FDR_scalar(MWW_FDR_table = fdt,
                                             MWW_FDR_threshold = 0.1)
      if(is.na(fdrscaler)){fdrscaler <- 1}
      cltable <- dmrscaler::write_CLT_lookup_table(num_reps = clt_reps ,
                                                   data_to_sample = mwr$p_val,
                                                   FDR_scaler = fdrscaler,
                                                   clt_numCGs = c(2, 5, 10, 25, 50))
      ## data <-  names, chr, pos,  scoring_value (-log10pval)
    #  data <- controlCGlocs
      data <- locs[,1:3]
      data$chr <- as.factor(data$chr)
      colnames(data)<-c("names","pos","chr")
      data$scoring_values <- mwr$p_val
    #  data$chr <- droplevels(data$chr)
      layer_sizes <- c(2,4,8,16,32,64)
      layers<-list()
      for(i in 1:length(layer_sizes)){
        print(paste("layer", i, sep="_"))
        nn_step_fraction = 2 
        nn_step_size <- floor(layer_sizes[i] / nn_step_fraction)
        nn <- dmrscaler::n_nearest_window_scoring_func(indat = data, n_nearest = layer_sizes[i], step_size = nn_step_size, FDR = fdrscaler)
        signn <- dmrscaler::determine_significant_windows(window_results=nn, indat=data, quants=cltable , quants_significance_cutoff = "0.9999" )
        signn <- dmrscaler::add_significance(three_window_list =  signn, lookup_table = cltable)
        
        ## multiple chromosomes each a list, coerce to single dataframe
        signn <- bind_rows(signn)
        ## 
        
        layers[[i]]<-signn
      }
      
      layers_TEMP_BACKUP <- layers
      layers<-layers_TEMP_BACKUP
      
      names(layers)<-paste("layer", layer_sizes, sep="_")
      
      # for(i in 1:length(layers)){
      #   temp<-as.data.frame(layers[[i]][[1]])
      #  # print(length(layers[[i]]))
      #   if(length(layers[[i]]) <= 1){ 
      #   layers[[i]]<-temp
      #   next
      #   }
      #   for(j in 2:length(layers[[i]])){
      #     temp<-rbind(temp, layers[[i]][[j]])
      #   }
      #   layers[[i]]<-temp[[1]]
      # }
      
      atomic_layer <- data
      for(i in 1:length(layers)){
        for(k in 1:length(layers[[i]]$start_pos)){
          layers[[i]]$start_index[k]<-which(atomic_layer$pos==layers[[i]]$start_pos[k] & as.character(atomic_layer$chr) == as.character(layers[[i]]$chr[k]))
          layers[[i]]$stop_index[k]<-which(atomic_layer$pos==layers[[i]]$stop_pos[k] & as.character(atomic_layer$chr) == as.character(layers[[i]]$chr[k]))
        }
      }
      built_layers <- list()
      built_layers[[1]] <- in_layer_merge(dmrs = layers[[1]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
      for(i in 2:length(layers)){
        #print(i)
        built_layers[[i]] <- build_next_layer(prev_layer = built_layers[[i-1]], 
                                              windows_to_layer = layers[[i]], 
                                              CG_table = atomic_layer,
                                              FDR_scaler=fdrscaler,
                                              lookup_table = cltable)
       # print("done with one")
      }



```


```{r  pair simulated with called regions }
#### Want: real, simulated (potentially many:many)
#### Want: DMRs  -2 -1 0 1 2 log10 DMRs called/ DMR simulated (for each DMR simulated count overlapping called DMRs + for each DMR called count overlapping called DMRs (map all to simulated DMRs, take max, record sign))
simul_dmrs <- data.frame("chr"=rep(0, length(dmr_names)),"pos"=rep(0, length(dmr_names)),"length"=rep(0, length(dmr_names)), "name"=rep(0, length(dmr_names) ) )
for(i in 1:length(dmr_names)){
  dmr_i <- dmr_names[i]
  simul_dmrs$chr[i] <- unique(locs$chr[which(locs$dmr_name==dmr_i)])
  simul_dmrs$pos[i] <- min(locs$pos[which(locs$dmr_name==dmr_i)])
  simul_dmrs$length[i] <- min(locs$dmr_size[which(locs$dmr_name==dmr_i)])
  simul_dmrs$name[i] <- dmr_names[i]
}
#simul_dmrs$chr <- paste("chr", simul_dmrs$chr, sep = "")

simul_grs <- GRanges(
  seqnames = simul_dmrs$chr,
  ranges = IRanges(start = simul_dmrs$pos, width = simul_dmrs$length, names = simul_dmrs$name ),
  strand = rep("*", nrow(simul_dmrs))
)

called_dmrs <- built_layers[[length(built_layers)]]
temp_names <- paste("called", called_dmrs$chr, called_dmrs$start_pos, sep = "_")
called_grs <- GRanges(
  seqnames = called_dmrs$chr,
  ranges = IRanges(start = called_dmrs$start_pos, end = called_dmrs$stop_pos, names = temp_names),
  strand = rep("*", nrow(called_dmrs))
)

## basis for generating simul_length vs called_length plot
overlaps <- findOverlaps(simul_grs, called_grs)
plot(log10(simul_grs@ranges@width[overlaps@from]), log10(called_grs@ranges@width[overlaps@to]))
cor( log10(simul_grs@ranges@width[overlaps@from]),log10(called_grs@ranges@width[overlaps@to]))
### write pairs of simul_width and called_width. To plot: plot log10 transformed widths  

############################################


##### one-to-one, many-to-one, one-to-many plot setup  
overlaps_count_simul <- countOverlaps( simul_grs, called_grs)
overlaps_count_simul 

overlaps_count_called <- countOverlaps( called_grs, simul_grs)
overlaps_count_called
overlap_count_called_df <- data.frame("names"=names(overlaps_count_called), "overlap_counts" = overlaps_count_called) 

count_called_per_simul <- vector(length = length(simul_grs) )
names(count_called_per_simul) <- simul_grs@ranges@NAMES

for(i in 1:length(simul_grs)){
  if(!is.element(i, overlaps@from)){ count_called_per_simul[i] <- 0; next;}
  which <- which(overlaps@from==i)  ## select rows of overlaps corresponding to simulated dmr
  max_overlapping_those_called_over_sim <-max(overlap_count_called_df[which,"overlap_counts"])
  if(overlaps_count_simul[i] >= max_overlapping_those_called_over_sim){ count_called_per_simul[i] <- overlaps_count_simul[i]}
  else{count_called_per_simul[i] <- 1/max_overlapping_those_called_over_sim}  ## fraction if multiple simulated map to single called
}
### save count_called_per_simul vector. To plot : density of log10 values.

################################


## error plots (missed dmrs and edge error for called dmrs)
####  trim edge to improve
#### 


```


```{r error_test Figures}
temp<-locs
temp$mwr<-temp$neglog10pval
a<-built_layers[[6]]
a$length <- a$stop_pos-a$start_pos

png(filename = "./results/08062020_CG_pval_dists_AND_DMR_sizes_dists.png")
par(mfrow=c(2,2))
hist(temp$mwr$p_val[which(temp$in_dmr==0)], breaks = 50, main = paste("CpGs NOT IN DMR (delta beta 0.8)"), xlab = paste("-log10pval"))
hist(temp$mwr$p_val[which(temp$in_dmr==1)], breaks = 50, main = paste("CpGs IN DMR  (delta beta 0.8)"), xlab = paste("-log10pval"))

hist(log10(a$length), breaks = 50, xlim=c(0,6.2), ylim=c(0,12), main = paste("Size of called DMRs"),xlab="log10(bp)")
hist(log10(unique( temp[,c("dmr_size","dmr_name")])$dmr_size), breaks=50, xlim=c(0,6.2), ylim=c(0,12), main = paste("Size of simulated DMRs"), xlab="log10(bp)")

dev.off()

length(unique( temp[,c("dmr_size","dmr_name")])$dmr_size)
nrow(a)


temps <- data.frame("chr"=rep(0, length(dmr_names)),"pos"=rep(0, length(dmr_names)),"length"=rep(0, length(dmr_names) ))
for(i in 1:length(dmr_names)){
  dmr_i <- dmr_names[i]
  temps$chr[i] <- unique(locs$chr[which(locs$dmr_name==dmr_i)])
  temps$pos[i] <- min(locs$pos[which(locs$dmr_name==dmr_i)])
  temps$length[i] <- min(locs$dmr_size[which(locs$dmr_name==dmr_i)])
}
temps$chr <- paste("chr", temps$chr, sep = "")
temps2 <- a[,c("chr","start_pos","length")]  

sort(temps2)


write.csv(temps, file = "./results/08062020_error_check_simulated_dmrs.csv")
write.csv(temps2, file = "./results/08062020_error_check_called_dmrs.csv")
```


```{r checking INDMR label with BETA}

locs$names[which(locs$in_dmr==1)]
hist(rowMeans(B_mod[locs$names[which(locs$in_dmr==1)],g1])- rowMeans(B_mod[locs$names[which(locs$in_dmr==1)],g2]), breaks = 40)
#rowMeans(B_mod[locs$names[which(locs$in_dmr==1)],g1])- rowMeans(B_mod[locs$names[which(locs$in_dmr==1)) 
locs$neglog10pval <- mwr
plot( rowMeans(B_mod[locs$names[which(locs$in_dmr==1)],g1])- rowMeans(B_mod[locs$names[which(locs$in_dmr==1)],g2]), locs$neglog10pval$p_val[which(locs$in_dmr==1)] )
### issue is in assigning significance? Looks like the INDMRs are proper being artificially inflated or deflated.. maybe an issue with control/ case assignment??

length(which(rownames(mwr)==locs$names))
length(which(rownames(B_mod)==locs$names))
locs$neglog10pval <- mwr




```








```{r run_simulation_multiple times}
WIDTH_PAIRS <- data.frame("method"=character(), "params"=character(),
                          "simulated_width"=numeric(), "called_width"=numeric())

MAPPING_VALUES <- data.frame("method"=character(), "params"=character(),
                             "simul_chr"=character(), "simul_start"=numeric(), "simul_width"=numeric(),
                             "mapping_value"=numeric(), "TP%"=numeric(), "FN%"=numeric())

CALLED_TP_FP <- data.frame("method"=character(), "params"=character(),
                             "called_chr"=character(), "called_start"=numeric(), "called_width"=numeric(),
                             "TP%"=numeric(), "FP%"=numeric(), "pval"=numeric())



#BH_WIDTH_PAIRS <- data.frame("simulated_width"=numeric(), "called_width"=numeric(), "param_string"=character())
#BH_MAPPING_VALUES <- data.frame("mapping_value"=numeric(), "param_string"=character())
#DMRCATE_WIDTH_PAIRS <- data.frame("simulated_width"=numeric(), "called_width"=numeric(), "param_string"=character())
#DMRCATE_MAPPING_VALUES <- data.frame("mapping_value"=numeric(), "param_string"=character())

for(RUN in 1:10){
        ## delta_beta = artificial inflation of beta values between groups
        ## num_samples = number of samples for each group
        ## noise = proportion of cgs in DMR that are not to have an altered beta value
        ## dmr_buffer = number of non-dmr cgs to enforce between each artificial dmr
        
        pars <- data.frame("delta_beta" = 0.2, "num_samples" = 8, "noise" = 0.5, "dmr_buffer" = 10) 
        
        
        
        ## r select dmrs ranges
        locs$in_dmr <- rep(0, nrow(locs))
        locs$dmr_size <- rep(0, nrow(locs))
        #locs$dmr_left_bound <- rep(0, nrow(locs))
        #locs$dmr_right_bound <- rep(0, nrow(locs))
        locs$dmr_name <- rep("", nrow(locs))
        
        for(i in 1:nrow(simul_sc_tbl)){
            size <- simul_sc_tbl[i,]$size
            min_cgs <- simul_sc_tbl[i,]$min_cgs
            count <- simul_sc_tbl[i,]$count
           
            while(count > 0){
                size_sampled <-sample(floor(size/10)+1:size,1) 
                x <- sample(1:nrow(locs),1)
                x_loc <-locs[x,]
                x_which <- which(locs$chr == x_loc$chr & locs$pos >= x_loc$pos & locs$pos <= x_loc$pos+size_sampled )
                x_which_left <- min(x_which)-10
                x_which_right <- max(x_which)+10
                if(x_which_left <  min(which(locs$chr == x_loc$chr)) ){next;} ## test if valid left bound
                if(x_which_right > max(which(locs$chr == x_loc$chr)) ){next;} ## test if valid right bound
                if(length(x_which) >= min_cgs  ## at least min_cgs 
                   & sum(locs$in_dmr[x_which_left:x_which_right])==0   ## not overlapping a dmr that already exists
                    & (locs$pos[max(x_which)]-locs$pos[min(x_which)] >= size/10)  ##  size is between size/2 and size
                   ){ ## min number cgs achieved and none in dmr already...
                    
                    x_which <- unique(c(min(x_which), sample(x_which, ceiling((1-pars$noise) * length(x_which) )  ) ,max(x_which))) ## sample left and right most cg and introduce noise 
                    locs$in_dmr[x_which] <- 1
                    locs$dmr_size[x_which] <- locs$pos[max(x_which)]-locs$pos[min(x_which)]
                    locs$dmr_name[x_which] <- paste("dmr", size, count, sep = "_")
                    # locs$dmr_left_bound[min(x_which)] <- 1
                    # locs$dmr_right_bound[max(x_which)] <- 1
                    count<-count-1
                    
                }
            }
        }
        
        #hist(log10(locs$dmr_size[which(locs$in_dmr==1)]), breaks=200)
        #locs$pos[35041] - locs$pos[34998]
        
        locs$chr <- as.character(locs$chr)  ## remove factor 
        
        
        
        
        ## {r select two groups to simulate dmr in}
        g12 <- sample(rownames(pdat), 2*pars$num_samples, replace = FALSE)
        g1 <- g12[1:pars$num_samples]
        g2 <- g12[(pars$num_samples+1):length(g12)]
        
        
        ##{r simulate dmrs in beta matrix}
        B_mod <- as.matrix(B[,g12])
        
        dmr_names <- unique(locs$dmr_name)[which(unique(locs$dmr_name)!="")]
        for(i in 1:length(dmr_names)){
          dmr_i <- dmr_names[i]
          locs_i <- locs$names[which(locs$dmr_name==dmr_i)]
          mean_g1_i <- mean(as.matrix(B_mod[locs_i,g1]))
          mean_g2_i <- mean(as.matrix(B_mod[locs_i,g2]))
          if(mean_g1_i > mean_g2_i){
             B_mod[locs_i, g1] <- B_mod[locs_i, g1]+pars$delta_beta 
          }else{ 
              B_mod[locs_i, g2] <- B_mod[locs_i, g2]+pars$delta_beta 
          }
        }
        
        B_test <- B[,g12]
        hist(as.matrix(B_test)-as.matrix(B_mod)) 
        
        length(is.element(rownames(B_mod)[which(rowMeans(as.matrix(B_test))-rowMeans(as.matrix(B_mod)) < -0.1)], locs$names[which(locs$in_dmr==1)]))
        
        ## {r}
              
              ############################     run everything         #########################
              num_perm <- 10
              clt_reps <- 5e4
              
              rim <- dmrscaler::generate_rand_index_matrix(num_controls = length(g1),
                                                           num_cases = length(g2),
                                                           num_permutations = num_perm)
              mrp <- dmrscaler::run_MWW_rand_permutation(index_matrix = rim, 
                                                         Beta = B_mod,
                                                         num_permutations = num_perm)
              mrp <- -log10(mrp)
              mwr <- dmrscaler::run_MWW(control_indices = which(colnames(B_mod)==g1) ,
                                        case_indices = which(colnames(B_mod)==g2),
                                        Beta = B_mod)
              mwr <- -log10(mwr)
              fdt <- dmrscaler::write_FDR_table(real_table = mwr,
                                                rand_table = mrp)
              
              fdrscaler <- dmrscaler::get_FDR_scalar(MWW_FDR_table = fdt,
                                                     MWW_FDR_threshold = 0.1)
              if(is.na(fdrscaler)){fdrscaler <- 1}
              cltable <- dmrscaler::write_CLT_lookup_table(num_reps = clt_reps ,
                                                           data_to_sample = mwr$p_val,
                                                           FDR_scaler = fdrscaler,
                                                           clt_numCGs = c(2, 5, 10, 25, 50))
              ## data <-  names, chr, pos,  scoring_value (-log10pval)
            #  data <- controlCGlocs
              data <- locs[,1:3]
              data$chr <- as.factor(data$chr)
              colnames(data)<-c("names","pos","chr")
              data$scoring_values <- mwr$p_val
            #  data$chr <- droplevels(data$chr)
              layer_sizes <- c(2,4,8,16,32,64)
              layers<-list()
              for(i in 1:length(layer_sizes)){
                print(paste("layer", i, sep="_"))
                nn_step_fraction = 2 
                nn_step_size <- floor(layer_sizes[i] / nn_step_fraction)
                nn <- dmrscaler::n_nearest_window_scoring_func(indat = data, n_nearest = layer_sizes[i], step_size = nn_step_size, FDR = fdrscaler)
                signn <- dmrscaler::determine_significant_windows(window_results=nn, indat=data, quants=cltable , quants_significance_cutoff = "0.9999" )
                signn <- dmrscaler::add_significance(three_window_list =  signn, lookup_table = cltable)
                
                ## multiple chromosomes each a list, coerce to single dataframe
                signn <- bind_rows(signn)
                ## 
                
                layers[[i]]<-signn
              }
              
              layers_TEMP_BACKUP <- layers
              layers<-layers_TEMP_BACKUP
              
              names(layers)<-paste("layer", layer_sizes, sep="_")
              
              # for(i in 1:length(layers)){
              #   temp<-as.data.frame(layers[[i]][[1]])
              #  # print(length(layers[[i]]))
              #   if(length(layers[[i]]) <= 1){ 
              #   layers[[i]]<-temp
              #   next
              #   }
              #   for(j in 2:length(layers[[i]])){
              #     temp<-rbind(temp, layers[[i]][[j]])
              #   }
              #   layers[[i]]<-temp[[1]]
              # }
                  
              atomic_layer <- data
              for(i in 1:length(layers)){
                for(k in 1:length(layers[[i]]$start_pos)){
                  layers[[i]]$start_index[k]<-which(atomic_layer$pos==layers[[i]]$start_pos[k] & as.character(atomic_layer$chr) == as.character(layers[[i]]$chr[k]))
                  layers[[i]]$stop_index[k]<-which(atomic_layer$pos==layers[[i]]$stop_pos[k] & as.character(atomic_layer$chr) == as.character(layers[[i]]$chr[k]))
                }
              }
              built_layers <- list()
              built_layers[[1]] <- in_layer_merge(dmrs = layers[[1]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
              built_layers[[1]] <- in_layer_merge(dmrs = built_layers[[1]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
              built_layers[[1]] <- trim_layer(dmrs = built_layers[[1]], CG_table = atomic_layer, FDR_scaler = 2, lookup_table = cltable)
              for(i in 2:length(layers)){
                #print(i)
                built_layers[[i]] <- build_next_layer(prev_layer = built_layers[[i-1]], 
                                                      windows_to_layer = layers[[i]], 
                                                      CG_table = atomic_layer,
                                                      FDR_scaler=fdrscaler,
                                                      lookup_table = cltable)
              built_layers[[i]] <- in_layer_merge(dmrs = built_layers[[i]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
              built_layers[[i]] <- in_layer_merge(dmrs = built_layers[[i]], CG_table = atomic_layer, FDR_scaler = fdrscaler, lookup_table = cltable)
              built_layers[[i]] <- trim_layer(dmrs = built_layers[[i]], CG_table = atomic_layer, FDR_scaler = 2, lookup_table = cltable)
               # print("done with one")
              }
        
        ## {r  pair simulated with called regions }
        #### Want: real, simulated (potentially many:many)
        #### Want: DMRs  -2 -1 0 1 2 log10 DMRs called/ DMR simulated (for each DMR simulated count overlapping called DMRs + for each DMR called count overlapping called DMRs (map all to simulated DMRs, take max, record sign))
        simul_dmrs <- data.frame("chr"=rep(0, length(dmr_names)),"pos"=rep(0, length(dmr_names)),"length"=rep(0, length(dmr_names)), "name"=rep(0, length(dmr_names) ) )
        for(i in 1:length(dmr_names)){
          dmr_i <- dmr_names[i]
          simul_dmrs$chr[i] <- unique(locs$chr[which(locs$dmr_name==dmr_i)])
          simul_dmrs$pos[i] <- min(locs$pos[which(locs$dmr_name==dmr_i)])
          simul_dmrs$length[i] <- min(locs$dmr_size[which(locs$dmr_name==dmr_i)])
          simul_dmrs$name[i] <- dmr_names[i]
        }
        #simul_dmrs$chr <- paste("chr", simul_dmrs$chr, sep = "")
        
        simul_grs <- GRanges(
          seqnames = simul_dmrs$chr,
          ranges = IRanges(start = simul_dmrs$pos, width = simul_dmrs$length, names = simul_dmrs$name ),
          strand = rep("*", nrow(simul_dmrs))
        )
        
        called_dmrs <- built_layers[[length(built_layers)]]
        temp_names <- paste("called", called_dmrs$chr, called_dmrs$start_pos, sep = "_")
        called_grs <- GRanges(
          seqnames = called_dmrs$chr,
          ranges = IRanges(start = called_dmrs$start_pos, end = called_dmrs$stop_pos, names = temp_names),
          strand = rep("*", nrow(called_dmrs))
        )
        called_grs$pval <- called_dmrs$unsigned_bin_score
        
        ## basis for generating simul_length vs called_length plot
        overlaps <- findOverlaps(simul_grs, called_grs)
        plot(log10(simul_grs@ranges@width[overlaps@from]), log10(called_grs@ranges@width[overlaps@to]))
        cor( log10(simul_grs@ranges@width[overlaps@from]),log10(called_grs@ranges@width[overlaps@to]))
        ### write pairs of simul_width and called_width. To plot: plot log10 transformed widths  
        WIDTH_PAIRS <- rbind(WIDTH_PAIRS, data.frame("method" = "DMRscaler",
                                                     "params" = "default" ,
                                                     "simulated_width"=simul_grs@ranges@width[overlaps@from],
                                                     "called_width"=called_grs@ranges@width[overlaps@to]))
        

        ############################################
        
        
        ##### one-to-one, many-to-one, one-to-many plot setup  
        overlaps_count_simul <- countOverlaps( simul_grs, called_grs)
        overlaps_count_simul 
        
        overlaps_count_called <- countOverlaps( called_grs, simul_grs)
        overlaps_count_called
        overlap_count_called_df <- data.frame("names"=as.numeric(names(overlaps_count_called)), "overlap_counts" = overlaps_count_called) 
        
        count_called_per_simul <- vector(length = length(simul_grs) )
        names(count_called_per_simul) <- simul_grs@ranges@NAMES
        
        for(i in 1:length(simul_grs)){
          if(!is.element(i, overlaps@from)){ count_called_per_simul[i] <- 0; next;}
          which <- overlaps@to[which(overlaps@from==i)]  ## select rows of overlaps corresponding to simulated dmr
          max_overlapping_those_called_over_sim <-max(overlap_count_called_df[which,"overlap_counts"])
          if(overlaps_count_simul[i] >= max_overlapping_those_called_over_sim){ count_called_per_simul[i] <- overlaps_count_simul[i]}
          else{count_called_per_simul[i] <- 1/max_overlapping_those_called_over_sim}  ## fraction if multiple simulated map to single called
        }
        
        ##Get TP FN values
        TP <- numeric(length = length(simul_grs))
        FN <- numeric(length = length(simul_grs))
        cs_intersect <-  intersect( called_grs, simul_grs) ##### write this....
        cs_overlap <- findOverlaps(simul_grs, cs_intersect )
        for(i in 1:length(simul_grs)){
          if(!is.element(i, cs_overlap@from)){ TP[i] <- 0; FN[i] <- 1;  next;}
          which<-cs_overlap@to[which(cs_overlap@from==i)]
          TP[i] <- sum(cs_intersect[which]@ranges@width) / simul_grs[i]@ranges@width
          FN[i] <- 1 - TP[i]
        }

        ### save count_called_per_simul vector. To plot : density of log10 values.
        MAPPING_VALUES <- rbind(MAPPING_VALUES, data.frame("method" = "DMRscaler",
                                                           "params" = "default" ,
                                                           "simul_chr"=simul_dmrs$chr, 
                                                           "simul_start"=simul_dmrs$pos, 
                                                           "simul_width"=simul_dmrs$length,
                                                           "mapping_value"= unname(count_called_per_simul),
                                                           "TP%"= TP,
                                                           "FN%"= FN))
        ##Get TP FP values
        TP <- numeric(length = length(called_grs))
        FP <- numeric(length = length(called_grs))
        cs_intersect <-  intersect( called_grs, simul_grs) ##### write this....
        cs_overlap <- findOverlaps(called_grs, cs_intersect )
        for(i in 1:length(called_grs)){
          if(!is.element(i, cs_overlap@from)){ TP[i] <- 0; FP[i] <- 1;  next;}
          which<-cs_overlap@to[which(cs_overlap@from==i)]
          TP[i] <- sum(cs_intersect[which]@ranges@width) / called_grs[i]@ranges@width
          FP[i] <- 1 - TP[i]
        }
        
        CALLED_TP_FP <- rbind(CALLED_TP_FP, data.frame("method" = "DMRscaler",
                                                       "params" = "default",
                                                       "called_chr"=as.character(called_dmrs$chr),
                                                       "called_start"=called_grs@ranges@start,
                                                       "called_width"=called_grs@ranges@width,
                                                       "TP%"= TP, 
                                                       "FP%"= FP, 
                                                       "pval"= called_grs$pval ))



        ################################
        
        
        ## error plots (missed dmrs and edge error for called dmrs)
        ####  trim edge to improve
        #### 

                            ##   BUMPHUNTER  ##
        design<-rep(-1,length(colnames(B_mod)))
        design[which(is.element(colnames(B_mod),g1))]<-1
        design<-cbind(rep(1,length(colnames(B_mod) ) ), design )
        bumps4 <- bumphunter(B_mod,as.matrix(design),chr = locs$chr, pos=locs$pos, cutoff=0.1, maxGap=1e6, B=250, smoothFunction=loessByCluster )
        temp_names <- paste("called", bumps4$table$chr, bumps4$table$start, sep = "_")
        called_grs <- GRanges(
          seqnames = bumps4$table$chr,
          ranges = IRanges(start = bumps4$table$start, end = bumps4$table$end, names = temp_names),
          strand = rep("*", nrow(bumps4$table))
        )
        called_grs$pval <- bumps4$table$p.value
        overlaps <- findOverlaps(simul_grs, called_grs)
        plot(log10(simul_grs@ranges@width[overlaps@from]), log10(called_grs@ranges@width[overlaps@to]))
        WIDTH_PAIRS <- rbind(WIDTH_PAIRS, data.frame("method" = "bumphunter",
                                             "params" = "maxGap=1e6,cutoff=0.1" ,
                                             "simulated_width"=simul_grs@ranges@width[overlaps@from],
                                             "called_width"=called_grs@ranges@width[overlaps@to]))


        
         ##### one-to-one, many-to-one, one-to-many plot setup   MAY NEED TO UPDATE
        overlaps_count_simul <- countOverlaps( simul_grs, called_grs)
        overlaps_count_simul 
        
        overlaps_count_called <- countOverlaps( called_grs, simul_grs)
        overlaps_count_called
        overlap_count_called_df <- data.frame("names"=as.numeric(names(overlaps_count_called)), "overlap_counts" = overlaps_count_called) 
        
        count_called_per_simul <- vector(length = length(simul_grs) )
        names(count_called_per_simul) <- simul_grs@ranges@NAMES
        
        for(i in 1:length(simul_grs)){
          if(!is.element(i, overlaps@from)){ count_called_per_simul[i] <- 0; next;}
          which <- overlaps@to[which(overlaps@from==i)]  ## select rows of overlaps corresponding to simulated dmr
          max_overlapping_those_called_over_sim <-max(overlap_count_called_df[which,"overlap_counts"])
          if(overlaps_count_simul[i] >= max_overlapping_those_called_over_sim){ count_called_per_simul[i] <- overlaps_count_simul[i]}
          else{count_called_per_simul[i] <- 1/max_overlapping_those_called_over_sim}  ## fraction if multiple simulated map to single called
        }
        
                ##Get TP FN values
        TP <- numeric(length = length(simul_grs))
        FN <- numeric(length = length(simul_grs))
        cs_intersect <-  intersect( called_grs, simul_grs) ##### write this....
        cs_overlap <- findOverlaps(simul_grs, cs_intersect )
        for(i in 1:length(simul_grs)){
          if(!is.element(i, cs_overlap@from)){ TP[i] <- 0; FN[i] <- 1;  next;}
          which<-cs_overlap@to[which(cs_overlap@from==i)]
          TP[i] <- sum(cs_intersect[which]@ranges@width) / simul_grs[i]@ranges@width
          FN[i] <- 1 - TP[i]
        }

        ### save count_called_per_simul vector. To plot : density of log10 values.
        MAPPING_VALUES <- rbind(MAPPING_VALUES, data.frame("method" = "bumphunter",
                                                           "params" = "maxGap=1e6,cutoff=0.1" ,
                                                           "simul_chr"=simul_dmrs$chr, 
                                                           "simul_start"=simul_dmrs$pos, 
                                                           "simul_width"=simul_dmrs$length,
                                                           "mapping_value"= unname(count_called_per_simul),
                                                           "TP%"= TP,
                                                           "FN%"= FN))
        ##Get TP FP values
        TP <- numeric(length = length(called_grs))
        FP <- numeric(length = length(called_grs))
        cs_intersect <-  intersect( called_grs, simul_grs) ##### write this....
        cs_overlap <- findOverlaps(called_grs, cs_intersect )
        for(i in 1:length(called_grs)){
          if(!is.element(i, cs_overlap@from)){ TP[i] <- 0; FP[i] <- 1;  next;}
          which<-cs_overlap@to[which(cs_overlap@from==i)]
          TP[i] <- sum(cs_intersect[which]@ranges@width) / called_grs[i]@ranges@width
          FP[i] <- 1 - TP[i]
        }
        
        CALLED_TP_FP <- rbind(CALLED_TP_FP, data.frame("method" = "bumphunter",
                                                       "params" = "maxGap=1e6,cutoff=0.1" ,
                                                       "called_chr"=as.character(called_grs@seqnames),
                                                       "called_start"=called_grs@ranges@start,
                                                       "called_width"=called_grs@ranges@width,
                                                       "TP%"= TP, 
                                                       "FP%"= FP, 
                                                       "pval"= called_grs$pval  ))

    
        ################################
        ####
        
        
        ##dmrcate##
        design<-rep(-1,length(colnames(B_mod)))
        design[which(is.element(colnames(B_mod),g1))]<-1
        design<-cbind(rep(1,length(colnames(B_mod) ) ), design )        
        colnames(design)<- c("(Intercept)","(Intercept)")
        B_mod <- as.matrix(B_mod)
        B_mod[which(B_mod <= 0)] <- min(B_mod[which(B_mod>0)])
        B_mod[which(B_mod >= 1)] <- max(B_mod[which(B_mod<1)])
        M <- log2(B_mod / (1-(B_mod)) )
        myannotation <- cpg.annotate("array", object=M, what="M", arraytype = "450K", analysis.type = "differential", design = design,  coef = 2)
        
        dmrcate_results <- dmrcate(myannotation, lambda=1e6, C=2000)
        called_grs <- extractRanges(dmrcoutput = dmrcate_results, genome="hg19")
        called_grs$pval <- called_grs$Stouffer
        overlaps <- findOverlaps(simul_grs, called_grs)
        
        WIDTH_PAIRS <- rbind(WIDTH_PAIRS, data.frame("method" = "DMRcate",
                                             "params" = "lambda=1e6_C=2000"  ,
                                             "simulated_width"=simul_grs@ranges@width[overlaps@from],
                                             "called_width"=called_grs@ranges@width[overlaps@to]))
        
        overlaps_count_simul <- countOverlaps( simul_grs, called_grs)
        overlaps_count_simul 
        
        overlaps_count_called <- countOverlaps( called_grs, simul_grs)
        overlaps_count_called
        overlap_count_called_df <- data.frame("names"=as.numeric(names(overlaps_count_called)), "overlap_counts" = overlaps_count_called) 
        
        count_called_per_simul <- vector(length = length(simul_grs) )
        names(count_called_per_simul) <- simul_grs@ranges@NAMES
        
        for(i in 1:length(simul_grs)){
          print(i)
          if(!is.element(i, overlaps@from)){ count_called_per_simul[i] <- 0; next;}
          
          which <- overlaps@to[which(overlaps@from==i)]  ## select rows of overlaps corresponding to simulated dmr
          max_overlapping_those_called_over_sim <-max(overlap_count_called_df[which(overlap_count_called_df$names==which),"overlap_counts"])
          
          if(overlaps_count_simul[i] >= max_overlapping_those_called_over_sim){ count_called_per_simul[i] <- overlaps_count_simul[i]}
          else{count_called_per_simul[i] <- 1/max_overlapping_those_called_over_sim}  ## fraction if multiple simulated map to single called
        }
        
        ##Get TP FN values
        TP <- numeric(length = length(simul_grs))
        FN <- numeric(length = length(simul_grs))
        cs_intersect <-  intersect( called_grs, simul_grs) ##### write this....
        cs_overlap <- findOverlaps(simul_grs, cs_intersect )
        for(i in 1:length(simul_grs)){
          if(!is.element(i, cs_overlap@from)){ TP[i] <- 0; FN[i] <- 1;  next;}
          which<-cs_overlap@to[which(cs_overlap@from==i)]
          TP[i] <- sum(cs_intersect[which]@ranges@width) / simul_grs[i]@ranges@width
          FN[i] <- 1 - TP[i]
        }

        ### save count_called_per_simul vector. To plot : density of log10 values.
        MAPPING_VALUES <- rbind(MAPPING_VALUES, data.frame("method" = "DMRcate",
                                                           "params" = "lambda=1e6_C=2000" ,
                                                           "simul_chr"=simul_dmrs$chr, 
                                                           "simul_start"=simul_dmrs$pos, 
                                                           "simul_width"=simul_dmrs$length,
                                                           "mapping_value"= unname(count_called_per_simul),
                                                           "TP%"= TP,
                                                           "FN%"= FN))
        ##Get TP FP values
        TP <- numeric(length = length(called_grs))
        FP <- numeric(length = length(called_grs))
        cs_intersect <-  intersect( called_grs, simul_grs) ##### write this....
        cs_overlap <- findOverlaps(called_grs, cs_intersect )
        for(i in 1:length(called_grs)){
          if(!is.element(i, cs_overlap@from)){ TP[i] <- 0; FP[i] <- 1;  next;}
          which<-cs_overlap@to[which(cs_overlap@from==i)]
          TP[i] <- sum(cs_intersect[which]@ranges@width) / called_grs[i]@ranges@width
          FP[i] <- 1 - TP[i]
        }
        
        CALLED_TP_FP <- rbind(CALLED_TP_FP, data.frame("method" = "DMRcate",
                                                       "params" = "lambda=1e6_C=2000" ,
                                                       "called_chr"=as.character(called_grs@seqnames),
                                                       "called_start"=called_grs@ranges@start,
                                                       "called_width"=called_grs@ranges@width,
                                                       "TP%"= TP, 
                                                       "FP%"= FP, 
                                                       "pval"= called_grs$pval  ))
        
        
        
        
        ####
        
        
        
}
#write.csv(WIDTH_PAIRS, file = "./results/10232020_WIDTH_PAIRS.csv")
#write.csv(MAPPING_VALUES, file = "./results/10232020_MAPPING_VALUES.csv")
#write.csv(CALLED_TP_FP, file = "./results/10232020_CALLED_TP_FP.csv")

#hist(log10(WIDTH_PAIRS$simulated_width))
#plot(log10(WIDTH_PAIRS$simulated_width),log10(WIDTH_PAIRS$called_width))
#a<-mean(log10(WIDTH_PAIRS$called_width))
#plot((log10(WIDTH_PAIRS$simulated_width)), (log10(WIDTH_PAIRS$called_width)-log10(WIDTH_PAIRS$simulated_width) ) )

#1- (sum((log10(WIDTH_PAIRS$called_width)-log10(WIDTH_PAIRS$simulated_width) )^2 ) /sum((log10(WIDTH_PAIRS$called_width)-a)^2 )) ## R squared

```


```{r}
dm_methods <- as.character(unique(WIDTH_PAIRS$method))
date <- format(Sys.Date(), format="%Y_%m_%d")

labels <- character(length = length(dm_methods))
names(labels)<-dm_methods
for(i in 1:length(dm_methods)){
  which <- which(WIDTH_PAIRS$method == dm_methods[i])
  cor <- cor(log10(WIDTH_PAIRS$simulated_width[which]), log10(WIDTH_PAIRS$called_width[which]))
  labels[i] <- paste(dm_methods[i], " (Pearson's R = ", round(cor,2), ")", sep = "" )
  names(labels[i])<-dm_methods[i]
}

sp + facet_grid(. ~ sex, labeller=labeller(sex = labels))


gg <- ggplot(WIDTH_PAIRS, aes(x=log10(simulated_width), y=log10(called_width))) +
  #ggtitle("simulated v called dmr length log10")+
  xlab("log10( Simulated DMR Width )")+
  ylab("log10( Called DMR Width )")+
 # stat_density_2d(aes(fill= ..level..),geom = "polygon",  n=50, h=0.6, alpha=0.8) +
  geom_point(size=0.01, alpha=0.4)+
  scale_fill_gradient(low="grey85", high="black")+
  theme_bw()+
  theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    text=element_text(size=3),
    strip.text = element_text(size=4, angle=0),
    axis.text = element_text(face="bold", size=4, angle=0)
  )+
  facet_grid(. ~ method, labeller=labeller(method = labels))
gg

filename<-paste(results_dir, date, "_ggsave_",  "sim_v_called_width.tiff", sep = "")
tiff(filename = filename, width = 8, height=4, units = "in", res = 500, pointsize = 1)

grid.arrange(gg, ncol=1)
dev.off()

ggsave(
  filename=filename,
  plot = gg,
  device = "tiff",
  path = NULL,
  scale = 1,
  width = 4,
  height = 2,
  units = c("in"),
  dpi = 320
)


```
